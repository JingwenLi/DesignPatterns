原型模式（Prototype）用于创建重复的对象
	用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。

	我们可以通过工厂方法模式去new一个对象，但是这个对象的状态是初始的转态，如果我们在开发中需要对象当时的状态，并且需要拷贝它的副本，而不是直接对原对象进行操作，这个时候工厂方法模式就失效了，这时有一种新的模式叫原型模式，

	通过复制一个已经存在的实例来创建一个新的实例，而且不需知道任何创建的细节。被复制的实例被称为原型，这个原型是可定制的。
	所有的原型类都必须有一个通用的接口，使得即使在对象所属的具体类未知的情况下也能复制对象。
	原型对象可以生成自身的完整副本， 因为相同类的对象可以相互访问对方的私有成员变量。

原型模式下主要角色:
	原型（Prototype）
		声明一个克隆自身的接口，该角色一般有抽象类(Prototype)、接口(ICloneable)两种实现方式

	具体原型类（ConcretePrototype）
		实现原型(抽象类或接口)的 Clone() 方法，它是可被复制的对象

	访问类（Client)
		使用具体原型类中的 Clone() 方法来复制新的对象。

优点
	1.性能高 : 使用原型模式复用的方式创建实例对象, 比使用构造函数重新创建对象性能要高 ( 针对类实例对象开销大的情况 )
	2.流程简单 : 原型模式可以简化创建的过程, 可以直接修改现有的对象实例的值, 达到复用的目的 ( 针对构造函数繁琐的情况 )
	3.原型模式简化了实例的创建结构，工厂方法模式需要有一个与产品类等级结构相同的等级结构，而原型模式不需要这样
	4.产品类不需要事先确定产品的等级结构，因为原型模式适用于任何的等级结构

缺点：
	1.每个类必须配备一个克隆方法。
	2.配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。

原型模式使用场景 : 
	原型模式的目的是 降低实例对象个数, 减少构造函数的调用次数
	1.类初始化消耗资源过多 : 如果类初始化时消耗过多的资源, 如这个类中某个成员占用大量内存, 为了节省开销
	2.初始化繁琐耗时 : 类对象创建时经过大量的计算, 或与本地资源 ( 数据库 , 文件 ) 频繁交互, 每次创建消耗大量的 CPU 与 时间资源
	3.构造函数复杂 : 类中定义的构造函数复杂
	4.实例对象数量庞大 : 如果在内存中循环创建了很多该实例对象 , 就可以使用原型模式复用不用的对象, 用于创建新对象

实现
假如有一个测试用例模板，项目A正在使用，公司又引进一个项目B，项目B的测试用例模板自己重新写一套肯定非常麻烦，那么可以使用项目A的用例模板，拿来改改就可以使用了。省却了许多时间。

使用浅拷贝实现：
	将原来对象中的所有字段逐个复制到一个新对象，如果字段是值类型，则简单地复制一个副本到新对象，改变新对象的值类型字段不会影响原对象；如果字段是引用类型，则复制的是引用，改变目标对象中引用类型字段的值将会影响原对象。
	例如, 如果一个对象有一个指向引用类型（如测试用例的名称）的字段, 并且我们对该对象做了一个浅复制, 那麽两个对象将引用同一个引用（即同一个测试用例名称）。

使用深拷贝实现：
	与浅复制不同之处在于对引用类型的处理，深复制将新对象中引用类型字段指向复制过的新对象，改变新对象中引用的任何对象，不会影响到原来的对象中对应字段的内容。
	例如，如果一个对象有一个指向引用类型（如测试用例的名称）的字段，并且对该对象做了一个深复制的话，将创建一个新的对象
	
ICloneable
public BusinessObject Clone()


